---
layout: post
title: Our JavaScript Tool Chain
tags:
- javascript
status: publish
type: post
---
For a long time JavaScript had a negative association with the term, "scripting language."
To this day, some people have the impression that JavaScript is not suited for large
complex apps. Whether the language is well suited to such a purpose remains a question, but
there are examples of maintainable, testable, large scale apps. Since we are
dealing with such a flexible language there are many ways and tool chains to use.

At Solid we're using the same tool chain across multiple projects to manage our JavaScript
apps. Recently a colleague and I went to the jQuery conference in Portland, and it looks
like many teams are using variants of this tool chain. The tool chain is MV* (MVC, MVP, MVPP
MVWTF...) (often Backbone), dependency management with AMD (usually requirejs), CSS compilation
from SASS, LESS, or other, and automated builds using Grunt. The builds usually include
running unit tests. There are many options for unit tests, we tend to use Jasmine.

> Our JavaScript Tool Chain

> * MV* & PubSub
>    * Backbone
> * Templating
>    * Underscore - client
>    * Jade - server
> * CSS management
>    * SASS
> * Dependency management
>    * RequireJS
> * Testing
>    * Jasmine
> * DOM interaction
>    * jQuery
> * Build manager
>    * Grunt

In addition to the basic tools above, we use several other tools that make the dev
environment nicer. For example we make use of livereload for SASS and JavaScript. We also
create documentation for projects, but have not yet found a preferred method to do so.

The purpose of all of these tools is to help organize thoughts and code.

Using an MV* framework forces you to separate the different concerns of your app to at least
some minimum level. In the past few years, many options for doing this have been written for
JavaScript. I like Backbone for its simplicity, it's readable source, and that it depends
on other libraries (jQuery and underscore) that I would use in a project even withouth
Backbone. The important thing about picking an MV* framework is not which one you pick,
but that you're trying to separate UI, data, and user interaction.

Templating is one of those things you don't realize you really need until after you start
using it. Just like doing things without MV*, it is possible to create apps without templating,
but once you start using templates, you won't want to stop. Templates separate variable
data from constants, and let you splice them together. It allows you to organize your code
more, and it makes it easier to split up work in a team, since one person can create
the templates that will be placed into the DOM, while another person can create the code that
injects the data into the templates. The ability to develop portions of your app piecemeal
like this is also one of the big advantages of using MV*. As long as the team can agree
on the interfaces ahead of time, they can work on individual components at their own pace.

For me, one of the most important recent changes in Web Development was CSS precompilers.
Working with CSS files that stretch to thousands of lines is painful. Not only is it almost
impossible to not repeat yourself, but where to add new CSS is often ambigous. Forcing
structure on to a large CSS file is possible, but it comes with the price of bloating your
total number of selectors, which will break IE. Finally, the biggest annoyance is that due
to a lack of variables, updating things like colors requires an error prone search and
replace tactic.

SASS let's you organize your CSS into files. It allows the use of reusable methods (mixins)
and variables. Additionally SASS support source maps, so that you know the corresponding
SASS lines to your CSS lines.

Asynchronous Module Definitions (AMD) is a more recent concept for JavaScript. Most other
languages have a means to create dependency hierarchies by defining and pulling
dependencies into files. AMD is the idea that solves this problem for JavaScript, and
Requirejs is a good and useful implentation of AMD. AMD is not perfect, but it is certainly
an improvement over tracking tens of script includes and what order they should be added.
Just like script includes (and build blocks), Requirejs can be optimized into one file.
Modules not only help in dependency management and ease of testing, they also conceptually
make you write code in small chunks.

To create apps with intricate and varied functionality, like many of the one page apps
on the web, it's necessary to write tens of thousands of lines of code. Many of the apps
we build run over 10k lines, and some run over 30k. One of the speakers (reference) said
the it is no longer, if it ever was, a badge of honor to work on a giant 10k JavaScript
file. Breaking the code up into modules makes general code management a more realistic
task, and it also helps a developer think about the code one little chunk at a time. This
reduces the total amount of code that you have to hold in your head at once. Modules also
make more decoupled, more testable, and more reusable code. Finally, AMD are loaded on the
fly, so Requirejs takes care of the load order, which means no more worrying about the
order of script tags in the head or body of a page. When ready to deploy, Requirejs
modules can be optimized into on file that is either stripped of Requirejs itself, or it
contains a minimal version called Almond.

Optimizing and sometimes deploying scripts with a build engine is also a common pattern.
Over the past year Grunt gained greatly in popularity. Grunt runs on Node which itself
uses a flavor of module definitions. One of the many nice things about Grunt is that it is
very flexible. You can
execute arbitrary system commands or even kick off other build processes with it. So, you
could both optimize the JavaScript in and Android project, as well due a full Maven or Ant
build for the Java. So, while the home site of Grunt says it is for use with JavaScript,
that is not necessarily so, and it can be used to build projects in theoretically any
language. We used it for several PHP projects. Grunt can also be used to deploy projects.
It is a great Swiss Army knife for developers who are most comfortable with JavaScript.

Large projects inevitably end up containing repeated code snippets and other boiler plate.
To keep things DRY (Don't Repeat Yourself), pulling boiler plate into factories or other
methods is very important. Several talks touched on jQuery UIs often overlooked Widget
Factory. The factory pattern is very simple and useful to implement in JavaScript.
Eliminating boiler plate not only saves the amount you have to type, but it makes
refactoring much simpler, since updating a method means only doing it in one centralized
place.

For example:

```
// without a factory
makeVisible: {
	this.addEventListeners();
	this.model.set("viewState:visibility", true);
},
addEventListeners: {
	this.listenTo(
}
```

Backbone has an especially large amount of such boilerplate, and there are some libraries
like Marionette that attempt to solve this problem.

jQuery plugins also have a large amount of boiler plate. To handle this, the jQuery UI team
created a jQuery plugin factory. There was also a talk introducing a similar and new jQuery
plugin factory. This is an illustration of using common design patterns in JavaScript.
Another common design pattern that was reference in many talks is the Publish / Subscribe
pattern.

There are many libraries including Backbone that use the PubSub pattern. There was a talk
about using events to help decouple views in a large app. There are many ways to use events
and to create even buses. In backbone models can be listened to. This allows things to
subscribe to changes on models. The use of changing and listening to changes in models
allows the decoupling of views in Backbone. Views can be injected with the models that they
 are interested in. This allows the coordination of multiple views based on important data.
 It allows views to not need to know of the existence of other views. Instead view can just
 respond to data and changes in data, which is much more modular and flexible.

 Events can also be triggered arbitrarily, unrelated to any model changes. A common way to
 do this is either by having a global event bus or through the use of more targeted channels.
 Backbone allows extending arbitrary objects with Events. In fact Backbone itself can be
 used as a global event bus. We use channels to broadcast events. For example if views can
 trigger or subscribe to the `channels.visible`. This would be a channel that views that are
 visible trigger events on. This allows the dropping of direct reference from other views.
 This can be especially helpful with modals and child or nested views.